@page "/analysis"
@inject AppStateViewModel state
@inject SignalRService signalR
@implements IDisposable

@using System.ComponentModel

<h1 class="display-4">Analysis</h1>

<div class="row">
    <div class="col-lg-8">
        <div class="card">
            <div class="card-header card-header-tabs card-header-info">
                <div class="nav-tabs-navigation">
                    <div class="nav-tabs-wrapper">
                        <ul class="nav nav-tabs w-100" data-tabs="tabs">
                            @foreach (ApiSource source in Enum.GetValues(typeof(ApiSource)).Cast<ApiSource>().Skip(1))
                            {
                                <li class="nav-item" onclick="@(() => this.SelectSource(source))">
                                    <a class="nav-link @((ApiSource)state.FpgaSettings.AS_Source == source ? "active" : "")" style="cursor:pointer">
                                        <i class="material-icons">show_chart</i> @state.ChartSettingsMap[source].Title
                                    </a>
                                </li>
                            }
                            <li class="nav-item ml-auto">
                                <a class="nav-link" style="cursor:pointer">
                                    <i class="material-icons" onclick="@this.ToggleRun">@(this.Run ? "pause_circle_filled" : "play_arrow")</i>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="card-body">
                <div class="tab-content">
                    <div class="tab-pane active">
                        @if ((ApiSource)state.FpgaSettings.AS_Source == ApiSource.NoSource)
                        {
                            <div class="alert alert-info mx-auto" style="max-width:400px;margin-top:170px;margin-bottom:170px;">
                                <span>
                                    <b>Info - </b> No data source selected. Click on one of the headers or load a configuration file.
                                </span>
                            </div>
                        }
                        <canvas height="130" id="chart" style="@((ApiSource)state.FpgaSettings.AS_Source == ApiSource.NoSource ? "display : none" : string.Empty)"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-4">
        @if ((ApiSource)state.FpgaSettings.AS_Source > ApiSource.NoSource)
        {
            @*<div class="row mb-2">
                <div class="col-md-10">
                    <div class="form-group bmd-form-group">
                        <label class="bmd-label-floating">Lower / Upper Threshold</label>
                    </div>
                </div>
                <div class="col-md-2">
                    <div class="form-group bmd-form-group">
                        <label class="bmd-label-floating">@state.FpgaData.LowerThreshold / @state.FpgaData.UpperThreshold</label>
                    </div>
                </div>
            </div>*@
            <div class="row mt-2">
                <div class="col">
                    <h5 style="margin-bottom:0px">Y-Limit Mode</h5>
                </div>
            </div>
            <div class="btn-group w-100" role="group">
                @foreach (ChartLimitMode limitMode in Enum.GetValues(typeof(ChartLimitMode)))
                {
                    <button type="button" class="btn @(this.ChartSettings.LimitMode == limitMode ? "btn-info" : "btn-default") @(limitMode == ChartLimitMode.Custom ? "w-100" : "")"
                            onclick="@(() => this.ChartSettings.LimitMode = limitMode)">
                        @Utilities.GetEnumLocalization((ChartLimitMode)limitMode, typeof(EnumerationDescription))
                    </button>
                }
            </div>
            @if (this.ChartSettings.LimitMode == ChartLimitMode.Custom)
            {
                <div class="input-group">
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="">Min:</span>
                    </div>
                    <input type="text" class="form-control mr-2" placeholder="Lower limit ..." bind="@this.ChartSettings.YMin" />
                    <div class="input-group-prepend">
                        <span class="input-group-text" id="">Max:</span>
                    </div>
                    <input type="text" class="form-control" placeholder="Upper limit ..." bind="@this.ChartSettings.YMax" />
                </div>
            }
        }
    </div>
</div>

@functions
{
    private bool _initialized;

    private bool Run { get; set; }
    private PropertyChangedEventHandler StateChangedHandler { get; set; }

    private ChartSettingsViewModel ChartSettings
    {
        get
        {
            return state.ChartSettingsMap[(ApiSource)state.FpgaSettings.AS_Source];
        }
    }

    protected override void OnInit()
    {
        _initialized = false;

        this.StateChangedHandler = async (sender, e) =>
        {
            List<ChartPoint> data1;
            List<ChartPoint> data2;

            if (e.PropertyName == nameof(state.FpgaData))
            {
                if (!this.Run)
                {
                    return;
                }

                data1 = null;
                data2 = null;

                switch ((ApiSource)state.FpgaSettings.AS_Source)
                {
                    case ApiSource.NoSource:
                        data1 = new List<ChartPoint>();
                        break;

                    case ApiSource.Raw:
                        data1 = state.FpgaData.Buffer.Select((value, i) => new ChartPoint(i * state.Summary.Step, unchecked((short)(value & 0x0000FFFF)))).ToList();
                        data2 = state.FpgaData.Buffer.Select((value, i) => new ChartPoint(i * state.Summary.Step, unchecked((short)(value >> 16)))).ToList();
                        break;

                    case ApiSource.Position:
                    case ApiSource.Filter:
                        data1 = state.FpgaData.Buffer.Select((value, i) => new ChartPoint(i * state.Summary.Step, unchecked((short)(value & 0x0000FFFF)))).ToList();
                        break;

                    case ApiSource.FourierTransform:

                        var real = state.FpgaData.Buffer.Select(value => unchecked((short)(value & 0x0000FFFF))).ToArray();
                        var imag = state.FpgaData.Buffer.Select(value => unchecked((short)(value >> 16))).ToArray();
                        var ampl = real.Zip(imag, (x, y) => Math.Sqrt(Math.Pow(x, 2) + Math.Pow(y, 2))).ToArray();
                        var count = ampl.Count();

                        data1 = ampl.Select((value, i) => new ChartPoint(i * state.Summary.Step, value)).ToList();
                        break;

                    default:
                        throw new ArgumentException();
                }

                if (data2 is null)
                {
                    data2 = new List<ChartPoint>();
                }

                await JSRuntime.Current.InvokeAsync<object>("Vibrometer.UpdateChartData", "chart", data1, data2);
            }
            else if (e.PropertyName == nameof(state.FpgaSettings))
            {
                await this.InitializeChart();
                base.StateHasChanged();
            }
            else if (e.PropertyName == nameof(state.ChartSettingsMap))
            {
                await this.UpdateChartLimits();
            }
        };

        state.PropertyChanged += this.StateChangedHandler;

        this.Run = true;
    }

    protected override async Task OnAfterRenderAsync()
    {
        if (!_initialized)
        {
            await this.InitializeChart();
            _initialized = true;
        }
    }

    private async Task InitializeChart()
    {
        string xLabel;

        switch ((ApiSource)state.FpgaSettings.AS_Source)
        {
            case ApiSource.NoSource:
                xLabel = string.Empty;
                break;
            case ApiSource.Raw:
                xLabel = $"time in {state.Summary.Unit}";
                break;
            case ApiSource.Position:
                xLabel = $"time in {state.Summary.Unit}";
                break;
            case ApiSource.Filter:
                xLabel = $"time in {state.Summary.Unit}";
                break;
            case ApiSource.FourierTransform:
                xLabel = $"frequency in {state.Summary.Unit}";
                break;
            default:
                throw new ArgumentException();
        }

        await JSRuntime.Current.InvokeAsync<object>("Vibrometer.InitializeChart", "chart", state.Summary.XMin, state.Summary.XMax, xLabel, this.ChartSettings);
    }

    private async Task UpdateChartLimits()
    {
        await JSRuntime.Current.InvokeAsync<object>("Vibrometer.UpdateChartLimits", "chart", this.ChartSettings);
    }

    private async void SelectSource(ApiSource source)
    {
        await signalR.Connection.InvokeAsync("UpdateSetting", ApiParameter.AS_Source.ToString(), (int)source);
    }

    private void ToggleRun()
    {
        this.Run = !this.Run;
    }

    public void Dispose()
    {
        state.PropertyChanged -= this.StateChangedHandler;
    }
}
